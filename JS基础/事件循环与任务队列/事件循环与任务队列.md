# 事件循环与任务队列

## 事件循环

概念非常简单。它是一个在 JavaScript 引擎等待任务、执行任务和休眠等待更多任务这几个状态之间的无穷无尽的循环

> <a href="https://zh.javascript.info/event-loop#shi-jian-xun-huan">事件循环</a>

##  执行栈 宏任务队列 微任务队列

JS具有三个“堆栈”： 

- 标准堆栈（standard stack）：

  所有的同步调用（函数调用）

- 微任务队列 microtask queue (or job queue or microtask stack)：

  具有更高优先级的所有异步操作（`process.nextTick`，`Promises`，`Object.observe`，`MutationObserver`）

- 宏任务队列 macrotask queue (or event queue, task queue, macrotask queue)

  具有较低优先级（`setTimeout`，`setInterval`，`setImmediate`，`requestAnimationFrame`，`用户I/O`，`UI呈现`）的所有异步操作

  

> https://segmentfault.com/a/1190000011198232

<img src="https://github.com/YuArtian/blog/blob/master/JS%E5%9F%BA%E7%A1%80/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/1.png?raw=true"/>

- JS引擎：解释并编译代码。负责维护任务队列，并通过 Event Loop 的机制，按顺序把任务放入栈中执行
- runtime：运行时，就是运行环境。提供对外接口供 JS 调用，比如，在 Node.js 环境中，我们可以通过 `require` 来引入模块；而在浏览器中，我们有 `window`、 DOM等。异步处理模块，就是 runtime 提供的，拥有和Js引擎互不干扰的线程

## 算法

具体的事件循环的算法（尽管跟[标准](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)相比是简化过的）：

1. 从**宏任务**队列出列并执行最前面的任务（比如 最开始的 `script`）
2. 执行所有的微任务：
   - 当微任务队列非空时：
     - 出列并运行最前面的微任务
     - 依次执行，直到微任务队列清空
3. 如有需要执行渲染（UI rending）
4. 如果宏任务队列为空，休眠直到一个宏任务出现
5. 到步骤 1 中

<img src=""/>

## 其他

### 创建一个新的宏任务

使用 `setTimeout(fn, 0)` 

可以将耗时的计算拆为小片段，使浏览器可以对用户行为作出反馈 和 展示计算的进度

### 创建新的微任务

- 使用 `queueMicrotask(fn)`
- `promise` 的处理函数也是进入到微任务队列

