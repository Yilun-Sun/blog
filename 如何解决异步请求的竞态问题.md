# 如何解决异步请求的竞态问题

> 疫情期间 大家带好口罩 ^ . ^

<img src="https://github.com/YuArtian/blog/blob/master/img/%E6%8F%92%E5%9B%BE/WechatIMG161.jpeg?raw=true" style="width:300px" />

## 引子

这大概是所有前端在实际工作中都要解决的问题吧。。。

在现在的交互场景中，搜索框里的实时下拉提示，地图缩放时的数据更新等等。。

只要你多次触发同一个动作 多次调用了同一个接口，你就要考虑时序的问题

这次所讨论的内容并不是给请求加`loading`的判断啊，或者节流啊防抖啊，或者 `async/await`啊之类的

因为在下面的场景中这些并不能解决问题。。

请注意，我们的接口响应时间是随机的，而且我们要得到最新的结果，也就是最后一个请求得到的响应

## 场景描述

现在页面上有一个输入框，随着用户的输入会不断发出异步请求，取回后端返回的结果渲染在页面上。

但是蛋疼的是，接口的响应时间并不确定，也就是说，有可能先请求的后返回，后请求的却先返回了。

如果不作处理，这会导致前端渲染的结果错误（不是最后一个请求返回的结果）

那么。。如何才能保证页面正确的渲染呢？

## 重现

我们可以先简单重现一下，领会一下精神，代码如下，效果如图

<img src="https://github.com/YuArtian/blog/blob/master/img/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E7%AB%9E%E6%80%81%E9%97%AE%E9%A2%98/1.png?raw=true" />

<img src="https://github.com/YuArtian/blog/blob/master/img/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E7%AB%9E%E6%80%81%E9%97%AE%E9%A2%98/2.gif?raw=true"/>

全部代码请见

以上

可以看到我们实际想渲染的是第四个请求的结果，但是却被第三的请求的结果后来居上了，导致了显示错误

## 简单粗暴的解决方式

最简单的想法就是记一下数（其实已经记了）。。。比较一下是不是最后一个就好了

<img src="https://github.com/YuArtian/blog/blob/master/img/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E7%AB%9E%E6%80%81%E9%97%AE%E9%A2%98/3.png?raw=true"/>

<img src="https://github.com/YuArtian/blog/blob/master/img/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E7%AB%9E%E6%80%81%E9%97%AE%E9%A2%98/4.gif?raw=true"/>

OK，这样看起来已经阔以了

但是这样简单的方法在实际使用中并不方便，你总是需要想办法返回一个计数，然后做比较判断。。每个请求还都要重写一遍。。

鉴于现代的异步请求基本上都会使用  `Promise` ，接下来我们就介绍一种结合了 `Promise` 和 `XHR.abort()` 的船新方法

## Promise 和 XHR.abort()

>  <a src="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort">`XMLHttpRequest` 提供的 `abort` 方法 </a>可以用来将 `XMLHttpRequest` 的 `readyState` 置为 0。这样就可以视为请求被 "终止" 了  ^ . ^
>
> 但是请注意，这只是前端视角上的"终止"，实际上请求还是会到达服务器的（后面我们会证明这一点）。
>
> 从 http 原理来讲，也没可能会有所谓的终止请求的。简单设想一下，前端发出一个删除数据的请求，正常的请求流程中，请求被服务器接受，后端操作数据库，删掉数据，然后把结果响应给前端。在这中间前端如果真的能在响应到达之前终止请求的话，那删掉的数据怎么办呢。。。   -，-
>
> 所有的终止方法都只能是在到达前端之后不做处理而已，这样在用户看来就是被"终止"了。

为了能真实的测试我们的请求和响应的情况，我们就真的写一个node服务出来吧

新建一个 `app.js` ， 代码如下

```javascript
const http = require('http');
const url = require('url')
const util = require('util')

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain; charset=utf-8');
  res.setHeader('Access-Control-Allow-Origin', '*');
  const { pathname, query } = url.parse(req.url, true);
  if (pathname === '/mock') {
    //随机时间
    let time = Math.random() * 1000
    console.log(`接受到第 ${query.index} 个模拟请求, ${time} ms 后响应`)
    setTimeout(_ => {
      console.log(`响应第 ${query.index} 个模拟请求`)
      res.end(query.index)
    }, time)
  }
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});

```

同样的，我们的前端请求也要写一个真实的

```javascript
/* 封装 XHR */
function xhrAdapter (index) {
  return new Promise(function (resolve, reject) {
    var request = new XMLHttpRequest();
    request.open('GET', `http://127.0.0.1:3000/mock?index=${index}`, true)
    request.onreadystatechange = function handleLoad () {
      if (!request || request.readyState !== 4) {
        return;
      }
      if (request.status === 0) {
        return;
      }
      var response = {
        data: request.responseText,
        status: request.status,
        statusText: request.statusText,
      };
      resolve(response);
    }
    request.send()
  })
}
```

全部代码请见



